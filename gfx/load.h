/* Generated with shader-compressor by NR4/Team210. */
#ifndef LOAD_H
#define LOAD_H
const char * load_frag =
"/* Hardcyber - PC-64k-Intro by Team210 at Deadline 2k19\n"
" * Copyright (C) 2019  Alexander Kraus <nr4@z10.info>\n"
" * \n"
" * This program is free software: you can redistribute it and/or modify\n"
" * it under the terms of the GNU General Public License as published by\n"
" * the Free Software Foundation, either version 3 of the License, or\n"
" * (at your option) any later version.\n"
" * \n"
" * This program is distributed in the hope that it will be useful,\n"
" * but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
" * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
" * GNU General Public License for more details.\n"
" * \n"
" * You should have received a copy of the GNU General Public License\n"
" * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n"
" */\n"
"\n"
"#version 130\n"
"\n"
"uniform float iTime;\n"
"uniform vec2 iResolution;\n"
"uniform float iProgress;\n"
"\n"
"const float pi = acos(-1.);\n"
"const vec3 c = vec3(1.,0.,-1.);\n"
"\n"
"void rand(in vec2 x, out float n)\n"
"{\n"
"    x += 400.;\n"
"    n = fract(sin(dot(sign(x)*abs(x) ,vec2(12.9898,78.233)))*43758.5453);\n"
"}\n"
"\n"
"// Creative Commons Attribution-ShareAlike 4.0 International Public License\n"
"// Created by David Hoskins.\n"
"// See https://www.shadertoy.com/view/4djSRW\n"
"void hash11(in float p, out float d)\n"
"{\n"
"    p = fract(p * .1031);\n"
"    p *= p + 33.33;\n"
"    p *= p + p;\n"
"    d = fract(p);\n"
"}\n"
"\n"
"// Creative Commons Attribution-ShareAlike 4.0 International Public License\n"
"// Created by David Hoskins.\n"
"// See https://www.shadertoy.com/view/4djSRW\n"
"void hash12(in vec2 p, out float d)\n"
"{\n"
"	vec3 p3  = fract(vec3(p.xyx) * .1031);\n"
"    p3 += dot(p3, p3.yzx + 33.33);\n"
"    d = fract((p3.x + p3.y) * p3.z);\n"
"}\n"
"\n"
"// Creative Commons Attribution-ShareAlike 4.0 International Public License\n"
"// Created by David Hoskins.\n"
"// See https://www.shadertoy.com/view/4djSRW\n"
"void hash21(in float p, out vec2 d)\n"
"{\n"
"	vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n"
"	p3 += dot(p3, p3.yzx + 33.33);\n"
"    d = fract((p3.xx+p3.yz)*p3.zy);\n"
"}\n"
"\n"
"// Creative Commons Attribution-ShareAlike 4.0 International Public License\n"
"// Created by David Hoskins.\n"
"// See https://www.shadertoy.com/view/4djSRW\n"
"void hash22(in vec2 p, out vec2 d)\n"
"{\n"
"	vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n"
"    p3 += dot(p3, p3.yzx+33.33);\n"
"    d = fract((p3.xx+p3.yz)*p3.zy);\n"
"}\n"
"\n"
"// Adapted from iq, https://www.shadertoy.com/view/XsXSz4\n"
"void dtriangle(in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2, out float dst)\n"
"{\n"
"	vec2 e0 = p1 - p0;\n"
"	vec2 e1 = p2 - p1;\n"
"	vec2 e2 = p0 - p2;\n"
"\n"
"	vec2 v0 = p - p0;\n"
"	vec2 v1 = p - p1;\n"
"	vec2 v2 = p - p2;\n"
"\n"
"	vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n"
"	vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n"
"	vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n"
"    \n"
"    float s = sign( e0.x*e2.y - e0.y*e2.x );\n"
"    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n"
"                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n"
"                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n"
"\n"
"	dst = -sqrt(d.x)*sign(d.y);\n"
"}\n"
"\n"
"void stroke(in float d0, in float s, out float d)\n"
"{\n"
"    d = abs(d0)-s;\n"
"}\n"
"\n"
"void dist(in vec2 a, in vec2 b, out float d)\n"
"{\n"
"    d = length(b-a);\n"
"}\n"
"\n"
"void lfnoise(in vec2 t, out float n)\n"
"{\n"
"    vec2 i = floor(t);\n"
"    t = fract(t);\n"
"    t = smoothstep(c.yy, c.xx, t);\n"
"    vec2 v1, v2;\n"
"    rand(i, v1.x);\n"
"    rand(i+c.xy, v1.y);\n"
"    rand(i+c.yx, v2.x);\n"
"    rand(i+c.xx, v2.y);\n"
"    v1 = c.zz+2.*mix(v1, v2, t.y);\n"
"    n = mix(v1.x, v1.y, t.x);\n"
"}\n"
"\n"
"void nearest_controlpoint(in vec2 x, out vec2 p)\n"
"{\n"
"    float dmin = 1.e5, \n"
"        d;\n"
"    vec2 dp,\n"
"        y = floor(x);\n"
"    \n"
"    float i = 0.;\n"
"    for(float i = -1.; i <= 1.; i += 1.)\n"
"        for(float j = -1.; j <= 1.; j += 1.)\n"
"        {\n"
"            hash22(y+vec2(i,j), dp);\n"
"            dp += y+vec2(i,j);\n"
"            dist(x, dp, d);\n"
"            if(d<dmin)\n"
"            {\n"
"                dmin = d;\n"
"                p = dp;\n"
"            }\n"
"        }\n"
"}\n"
"\n"
"void dvoronoi(in vec2 x, out float d, out vec2 p, out float control_distance)\n"
"{\n"
"    d = 1.e4;\n"
"    vec2 y,\n"
"        dp;\n"
"    \n"
"    nearest_controlpoint(x, p);\n"
"    y = floor(p);\n"
"    \n"
"    control_distance = 1.e4;\n"
"    \n"
"    for(float i = -2.; i <= 2.; i += 1.)\n"
"        for(float j = -2.; j <= 2.; j += 1.)\n"
"        {\n"
"            if(i==0. && j==0.) continue;\n"
"            hash22(y+vec2(i,j), dp);\n"
"            dp += y+vec2(i,j);\n"
"            vec2 o = p - dp;\n"
"            float l = length(o);\n"
"            d = min(d,abs(.5*l-dot(x-dp,o)/l));\n"
"            control_distance = min(control_distance,.5*l);\n"
"        }\n"
"}\n"
"\n"
"void dbox(in vec2 x, in vec2 b, out float d)\n"
"{\n"
"    vec2 da = abs(x)-b;\n"
"    d = length(max(da,c.yy)) + min(max(da.x,da.y),0.0);\n"
"}\n"
"\n"
"void dlinesegment(in vec2 x, in vec2 p1, in vec2 p2, out float d)\n"
"{\n"
"    vec2 da = p2-p1;\n"
"    d = length(x-mix(p1, p2, clamp(dot(x-p1, da)/dot(da,da),0.,1.)));\n"
"}\n"
"\n"
"const vec3 orange =vec3(0.20,0.60,0.86),\n"
"    redorange = vec3(0.27,0.70,0.62);\n"
"void ddecorations(in vec2 x, in float decs, out float d)\n"
"{\n"
"    float r, v, vz;\n"
"    vec2 y, yi;\n"
"    \n"
"    dvoronoi(x/decs, v, yi, vz);\n"
"    y = x-yi*decs;\n"
" \n"
"    hash12(yi*decs, r);\n"
"    if(r < .5)\n"
"    {\n"
"        dbox(y, vz*decs/sqrt(2.)*c.xx, d);\n"
"    }\n"
"    else\n"
"    {\n"
"        hash11(r, r);\n"
"        d = length(y)-vz*decs;\n"
"    }\n"
"}\n"
"\n"
"void modgradient(in vec2 x, in float decs, inout vec3 col)\n"
"{\n"
"    float y = mod(x.y, decs)-.5*decs;\n"
"    \n"
"    col = mix(orange, redorange, 2.*abs(y)/decs);\n"
"}\n"
"\n"
"float sm(in float d)\n"
"{\n"
"    return smoothstep(1.5/iResolution.y, -1.5/iResolution.y, d);\n"
"}\n"
"\n"
"void smoothmin(in float a, in float b, in float k, out float dst)\n"
"{\n"
"    float h = max( k-abs(a-b), 0.0 )/k;\n"
"    dst = min( a, b ) - h*h*h*k*(1.0/6.0);\n"
"}\n"
"\n"
"void dloading(in vec2 uv, out float d)\n"
"{\n"
"    d = 1.;\n"
"    float da = 1.,\n"
"        db,\n"
"        dc = 1.;\n"
"    \n"
"    //L\n"
"    dlinesegment(uv, vec2(-.75,-.75), vec2(-.75, .75), da);\n"
"    d = min(d, da);\n"
"    dlinesegment(uv, vec2(-.75,-.75), vec2(.65, -.75), da);\n"
"    d = min(d, da);\n"
"    \n"
"    dlinesegment(uv, vec2(-.65,-.1), vec2(-.65,-.65), db);\n"
"    dc = min(dc, db);\n"
"    \n"
"    uv -= 2.*c.xy;\n"
"    \n"
"    //O\n"
"    dlinesegment(uv, vec2(-.75,-.75), vec2(.75, -.75), da);\n"
"    d = min(d, da);\n"
"    dlinesegment(uv, vec2(-.75,.75), vec2(.75, .75), da);\n"
"    d = min(d, da);\n"
"    dlinesegment(uv, vec2(-.75,-.75), vec2(-.75, .75), da);\n"
"    d = min(d, da);\n"
"    dlinesegment(uv, vec2(.75,-.75), vec2(.75, .75), da);\n"
"    d = min(d, da);\n"
"    \n"
"    dlinesegment(uv, vec2(.65,.35), vec2(.65,.65), db);\n"
"    dc = min(dc, db);\n"
"    \n"
"    uv -= 2.*c.xy;\n"
"    \n"
"    //A\n"
"    dlinesegment(uv, vec2(-.65,-.75), vec2(-.65,.75), da);\n"
"    d = min(d, da);\n"
"    dlinesegment(uv, vec2(.65,0.), vec2(.65,.75), da);\n"
"    d = min(d, da);\n"
"    dlinesegment(uv, vec2(-.65,.75), vec2(.65, .75), da);\n"
"    d = min(d, da);\n"
"    dlinesegment(uv, vec2(-.65,0.), vec2(.65, 0.), da);\n"
"    d = min(d, da);\n"
"    \n"
"    dlinesegment(uv, vec2(-.75,-.75), vec2(-.75,0.), db);\n"
"    dc = min(dc, db);\n"
"    dlinesegment(uv, vec2(.75,0.), vec2(.75,-.75), db);\n"
"    dc = min(dc, db);\n"
"    \n"
"    uv -= 2.*c.xy;\n"
"    \n"
"    //D\n"
"    dlinesegment(uv, vec2(-.75,-.75), vec2(.75, -.75), da);\n"
"    d = min(d, da);\n"
"    dlinesegment(uv, vec2(-.75,.75), vec2(.75, .75), da);\n"
"    d = min(d, da);\n"
"    dlinesegment(uv, vec2(-.75,-.75), vec2(-.75, .75), da);\n"
"    d = min(d, da);\n"
"    dlinesegment(uv, vec2(.75,-.75), vec2(.75, .75), da);\n"
"    d = min(d, da);\n"
"    \n"
"    dlinesegment(uv, vec2(-.65,-.1), vec2(-.65,-.65), db);\n"
"    dc = min(dc, db);\n"
"    \n"
"    uv -= 2.*c.xy;\n"
"    \n"
"    //I\n"
"    dlinesegment(uv, vec2(0.,-.75), vec2(0., .75), da);\n"
"    d = min(d, da);\n"
"    \n"
"    dlinesegment(uv, vec2(.1,-.75), vec2(.1,0.), db);\n"
"    dc = min(dc, db);\n"
"    \n"
"    uv -= 2.*c.xy;\n"
"    \n"
"    //N\n"
"    dlinesegment(uv, vec2(-.75,.75), vec2(.75, .75), da);\n"
"    d = min(d, da);\n"
"    dlinesegment(uv, vec2(-.75,-.75), vec2(-.75, .75), da);\n"
"    d = min(d, da);\n"
"    dlinesegment(uv, vec2(.75,-.75), vec2(.75, .75), da);\n"
"    d = min(d, da);\n"
"    \n"
"    dlinesegment(uv, vec2(-.65,-.1), vec2(-.65,-.75), db);\n"
"    dc = min(dc, db);\n"
"    \n"
"    uv -= 2.*c.xy;\n"
"    \n"
"    //G\n"
"    dlinesegment(uv, vec2(-.75,-.75), vec2(.75, -.75), da);\n"
"    d = min(d, da);\n"
"    dlinesegment(uv, vec2(-.75,.75), vec2(.75, .75), da);\n"
"    d = min(d, da);\n"
"    dlinesegment(uv, vec2(-.75,-.75), vec2(-.75, .75), da);\n"
"    d = min(d, da);\n"
"    dlinesegment(uv, vec2(.75,.5), vec2(.75, .75), da);\n"
"    d = min(d, da);\n"
"    dlinesegment(uv, vec2(.75,0.), vec2(.75, -.75), da);\n"
"    d = min(d, da);\n"
"    dlinesegment(uv, vec2(.75,0.), vec2(.25, 0.), da);\n"
"    d = min(d, da);\n"
"    \n"
"    dlinesegment(uv, vec2(-.65,-.1), vec2(-.65,-.65), db);\n"
"    dc = min(dc, db);\n"
"    \n"
"    for(int i=0; i<3; ++i)\n"
"    {\n"
"        uv -= 2.*c.xy;\n"
"        dlinesegment(uv, vec2(0.,-.55), vec2(0., -.65), da);\n"
"        d = min(d, da);\n"
"        \n"
"        dlinesegment(uv, vec2(.1,-.55), vec2(.1,-.65), db);\n"
"        dc = min(dc, db);\n"
"    }\n"
"    stroke(d,.1,d);\n"
"    stroke(dc, .1, dc);\n"
"    smoothmin(d,dc,.1,d);\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"    float d;\n"
"    vec2 uv = (gl_FragCoord.xy-.5*iResolution)/iResolution.y;\n"
"    vec3 col = c.yyy,\n"
"        c1 = col;\n"
"    \n"
"    // Background geraffel\n"
"    for(float decs = .05; decs <= 1.; decs += .05)\n"
"    {\n"
"        modgradient(uv, decs, c1);\n"
"        \n"
"        ddecorations(uv-1337.-12.*decs*c.yx, decs, d);\n"
"        \n"
"        float m;\n"
"        lfnoise((1.+5.*decs)*uv-1337.-12.*decs*c.yx, m);\n"
"        \n"
"        col = mix(col, mix(col,c1,mix(.6,.1,.8+.2*m)* mix(1., 0., clamp(length(uv),0.,1.))), sm(d));\n"
"        stroke(d, .001, d);\n"
"        col = mix(col, orange, sm(d));\n"
"    }\n"
"    \n"
"    col = mix(col, c.yyy, .2);\n"
"    \n"
"    // Background loading bar window\n"
"    dbox(uv, vec2(.3,.2), d);\n"
"    vec3 gcol = length(col)/sqrt(3.)*c.xxx;\n"
"    vec3 window_raw = vec3(0.08,0.07,0.16);\n"
"    vec3 window_background = mix(mix(col,window_raw,.2), mix(gcol,window_raw,.8), clamp((.5-uv.y/.4),0.,1.));\n"
"    col = mix(col, window_background, sm(d));\n"
"    \n"
"    // White border on loading bar window\n"
"    d = abs(d-.002)-.002;\n"
"    d = mix(d, 1., step(abs(uv.y),.19));\n"
"    col = mix(col, c.xxx, sm(d));\n"
"    \n"
"    // Progress bar outline\n"
"    dbox(uv, vec2(.28,.02), d);\n"
"    d = abs(d-.001)-.001;\n"
"    d = mix(d, 1., step(abs(uv.y),.015));\n"
"    col = mix(col, c.xxx, sm(d));\n"
"    \n"
"    // Progress bar value\n"
"    float w = .275;\n"
"    dbox(uv+mix(w,0.,iProgress)*c.xy, vec2(mix(0.,w,iProgress),.01), d);\n"
"    col = mix(col, c.xxx, sm(d));\n"
"    \n"
"    // X box\n"
"    dbox(uv-vec2(.26,.16), .015*c.xx, d);\n"
"    col = mix(col, c.xxx, sm(d+.005));\n"
"    stroke(d, .001, d);\n"
"    col = mix(col, c.xxx, sm(d));\n"
"    \n"
"    // Actual x\n"
"    dlinesegment(uv,vec2(.25,.15),vec2(.27,.17),d);\n"
"    float da;\n"
"    dlinesegment(uv,vec2(.25,.17),vec2(.27,.15),da);\n"
"    d = min(d,da);\n"
"    stroke(d,.002, d);\n"
"    col = mix(col, c.yyy, sm(d));\n"
"    \n"
"    // Loading... text\n"
"    dloading(60.*(uv-vec2(-.26,.05)),d);\n"
"    d /= 60.;\n"
"    d -= .002;\n"
"    col = mix(col, c.xxx, sm(d));\n"
"    \n"
"    gl_FragColor = vec4(clamp(col,0.,1.),1.);\n"
"}\n"
"\n"
;
#endif
